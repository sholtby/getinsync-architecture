# GetInSync APM Chat - Implementation Guide v2
**Based on NextGen Schema (2026-01-25)**

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│  React Frontend (Antigravity)                               │
│  └── <ApmChatPanel />                                       │
└─────────────────────┬───────────────────────────────────────┘
                      │ POST /functions/v1/apm-chat
┌─────────────────────▼───────────────────────────────────────┐
│  Supabase Edge Function                                     │
│  1. Auth → get namespace_id (tenant)                        │
│  2. Embed query → OpenAI                                    │
│  3. Vector search → namespace-scoped                        │
│  4. Detect query type (lookup vs analysis)                  │
│  5. For analysis: fetch supplemental data                   │
│  6. Build prompt → Claude API                               │
│  7. Stream response                                         │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────────────┐
│  Supabase PostgreSQL + pgvector                             │
│  ├── apm_embeddings (semantic search)                       │
│  └── Views for analysis (vw_budget_status, etc.)            │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. Database Setup

### Enable pgvector
```sql
create extension if not exists vector;
```

### Embeddings Table
```sql
create table apm_embeddings (
  id uuid default gen_random_uuid() primary key,
  namespace_id uuid not null references namespaces(id) on delete cascade,
  workspace_id uuid references workspaces(id) on delete cascade,
  
  -- Entity reference
  entity_type text not null,  
  -- Values: 'application', 'deployment_profile', 'software_product', 
  --         'it_service', 'technology_product', 'portfolio_assignment'
  entity_id uuid not null,
  
  -- Embedding data
  content text not null,
  embedding vector(1536),
  
  -- Denormalized for filtering
  metadata jsonb default '{}',
  -- Example: { "time_quadrant": "Migrate", "lifecycle_status": "Legacy", "has_tech_debt": true }
  
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  
  unique(namespace_id, entity_type, entity_id)
);

-- IVFFlat index for similarity search
create index idx_apm_embeddings_vector 
on apm_embeddings using ivfflat (embedding vector_cosine_ops)
with (lists = 100);

-- Filter indexes
create index idx_apm_embeddings_namespace on apm_embeddings(namespace_id);
create index idx_apm_embeddings_workspace on apm_embeddings(workspace_id);
create index idx_apm_embeddings_type on apm_embeddings(entity_type);

-- RLS
alter table apm_embeddings enable row level security;

create policy "Namespace isolation" on apm_embeddings
  for all using (namespace_id = (auth.jwt()->>'namespace_id')::uuid);
```

### Similarity Search Function
```sql
create or replace function search_apm_context(
  query_embedding vector(1536),
  p_namespace_id uuid,
  p_workspace_id uuid default null,
  p_entity_types text[] default null,
  match_count int default 8
)
returns table (
  entity_type text,
  entity_id uuid,
  workspace_id uuid,
  content text,
  metadata jsonb,
  similarity float
)
language plpgsql
security definer
as $$
begin
  return query
  select
    e.entity_type,
    e.entity_id,
    e.workspace_id,
    e.content,
    e.metadata,
    1 - (e.embedding <=> query_embedding) as similarity
  from apm_embeddings e
  where e.namespace_id = p_namespace_id
    and (p_workspace_id is null or e.workspace_id = p_workspace_id)
    and (p_entity_types is null or e.entity_type = any(p_entity_types))
  order by e.embedding <=> query_embedding
  limit match_count;
end;
$$;
```

---

## 2. Embedding Content Builders

The key to good RAG is rich, semantic content. Here's how to build embedding text for each entity:

```typescript
// lib/embedding-builders.ts

import { SupabaseClient } from '@supabase/supabase-js';

export async function buildApplicationContent(
  supabase: SupabaseClient,
  appId: string
): Promise<{ content: string; metadata: Record<string, any> }> {
  
  // Fetch app with related data
  const { data: app } = await supabase
    .from('applications')
    .select(`
      *,
      workspace:workspaces(name),
      owner_workspace:workspaces!owner_workspace_id(name),
      deployment_profiles(
        id, name, environment, hosting_type, cloud_provider,
        assessment_status, estimated_tech_debt, dp_type,
        t01, t02, t03, t04, t05, t06, t07, t08, t09, t10, t11, t12, t13, t14, t15
      ),
      portfolio_assignments(
        time_quadrant, paid_quadrant, business_score, technical_score,
        criticality_score, tech_risk_score,
        portfolio:portfolios(name)
      ),
      application_contacts(
        role_type, is_primary,
        contact:contacts(display_name, job_title)
      )
    `)
    .eq('id', appId)
    .single();

  if (!app) throw new Error(`Application ${appId} not found`);

  // Get primary deployment profile
  const primaryDp = app.deployment_profiles?.find((dp: any) => dp.is_primary) 
    || app.deployment_profiles?.[0];
  
  // Get portfolio assignment (for TIME quadrant)
  const assignment = app.portfolio_assignments?.[0];
  
  // Get contacts by role
  const businessOwner = app.application_contacts?.find(
    (c: any) => c.role_type === 'business_owner' && c.is_primary
  );
  const techOwner = app.application_contacts?.find(
    (c: any) => c.role_type === 'technical_owner' && c.is_primary
  );

  const content = `
APPLICATION: ${app.name}
App ID: ${app.app_id}
Workspace: ${app.workspace?.name || 'Unknown'}
${app.owner_workspace ? `Owner Workspace: ${app.owner_workspace.name}` : ''}

DESCRIPTION:
${app.description || 'No description provided'}

LIFECYCLE & CLASSIFICATION:
- Lifecycle Status: ${app.lifecycle_status || 'Not set'}
- TIME Quadrant: ${assignment?.time_quadrant || 'Not assessed'}
- PAID Quadrant: ${assignment?.paid_quadrant || 'Not assessed'}
- Portfolio: ${assignment?.portfolio?.name || 'Default Portfolio'}

SCORES:
- Business Score: ${assignment?.business_score ?? 'Not assessed'}
- Technical Score: ${assignment?.technical_score ?? 'Not assessed'}
- Criticality Score: ${assignment?.criticality_score ?? 'Not assessed'}
- Tech Risk Score: ${assignment?.tech_risk_score ?? 'Not assessed'}

FINANCIALS:
- Annual Cost: $${(app.annual_cost || 0).toLocaleString()}
- Budget Amount: $${(app.budget_amount || 0).toLocaleString()}
- Budget Locked: ${app.budget_locked ? 'Yes' : 'No'}
${app.budget_notes ? `- Budget Notes: ${app.budget_notes}` : ''}

DEPLOYMENT:
${primaryDp ? `
- Environment: ${primaryDp.environment}
- Hosting: ${primaryDp.hosting_type || 'Not specified'}
- Cloud Provider: ${primaryDp.cloud_provider || 'Not specified'}
- Assessment Status: ${primaryDp.assessment_status}
- Estimated Tech Debt: $${(primaryDp.estimated_tech_debt || 0).toLocaleString()}
` : '- No deployment profile configured'}

OWNERSHIP:
- Business Owner: ${businessOwner?.contact?.display_name || app.owner || 'Not assigned'}
- Technical Owner: ${techOwner?.contact?.display_name || app.primary_support || 'Not assigned'}
${app.secondary_support ? `- Secondary Support: ${app.secondary_support}` : ''}
  `.trim();

  const metadata = {
    time_quadrant: assignment?.time_quadrant,
    paid_quadrant: assignment?.paid_quadrant,
    lifecycle_status: app.lifecycle_status,
    assessment_status: primaryDp?.assessment_status,
    has_tech_debt: (primaryDp?.estimated_tech_debt || 0) > 0,
    annual_cost: app.annual_cost,
    workspace_name: app.workspace?.name,
  };

  return { content, metadata };
}


export async function buildDeploymentProfileContent(
  supabase: SupabaseClient,
  dpId: string
): Promise<{ content: string; metadata: Record<string, any> }> {
  
  const { data: dp } = await supabase
    .from('deployment_profiles')
    .select(`
      *,
      application:applications(name, app_id),
      workspace:workspaces(name),
      software_products:deployment_profile_software_products(
        deployed_version, annual_cost, contract_end_date,
        software_product:software_products(name, lifecycle_state)
      ),
      technology_products:deployment_profile_technology_products(
        technology_product:technology_products(name, category:technology_product_categories(name))
      ),
      it_services:deployment_profile_it_services(
        allocation_basis, allocation_value,
        it_service:it_services(name, service_type:service_types(name))
      )
    `)
    .eq('id', dpId)
    .single();

  if (!dp) throw new Error(`Deployment Profile ${dpId} not found`);

  // Build software product list
  const softwareList = dp.software_products?.map((sp: any) => 
    `  - ${sp.software_product?.name} v${sp.deployed_version || '?'} ` +
    `(${sp.software_product?.lifecycle_state}, $${sp.annual_cost?.toLocaleString() || 0}/yr)` +
    (sp.contract_end_date ? ` [Contract ends: ${sp.contract_end_date}]` : '')
  ).join('\n') || '  None';

  // Build technology list
  const techList = dp.technology_products?.map((tp: any) =>
    `  - ${tp.technology_product?.name} (${tp.technology_product?.category?.name || 'Uncategorized'})`
  ).join('\n') || '  None';

  // Build IT services list
  const serviceList = dp.it_services?.map((svc: any) =>
    `  - ${svc.it_service?.name} (${svc.it_service?.service_type?.name || 'Unknown type'})`
  ).join('\n') || '  None';

  // Calculate T-score summary
  const tScores = [dp.t01, dp.t02, dp.t03, dp.t04, dp.t05, dp.t06, dp.t07, 
                   dp.t08, dp.t09, dp.t10, dp.t11, dp.t12, dp.t13, dp.t14, dp.t15]
    .filter(s => s !== null);
  const avgTScore = tScores.length > 0 
    ? (tScores.reduce((a, b) => a + b, 0) / tScores.length).toFixed(1)
    : 'Not assessed';

  const content = `
DEPLOYMENT PROFILE: ${dp.name}
Application: ${dp.application?.name || 'Standalone'} (App ID: ${dp.application?.app_id || 'N/A'})
Workspace: ${dp.workspace?.name}
Type: ${dp.dp_type}

INFRASTRUCTURE:
- Environment: ${dp.environment}
- Hosting Type: ${dp.hosting_type || 'Not specified'}
- Cloud Provider: ${dp.cloud_provider || 'Not specified'}
- Region: ${dp.region || 'Not specified'}
- DR Status: ${dp.dr_status || 'Not specified'}
- Is Primary: ${dp.is_primary ? 'Yes' : 'No'}

ASSESSMENT:
- Status: ${dp.assessment_status}
- Average T-Score: ${avgTScore}
- T-Scores Completed: ${tScores.length}/15

COSTS:
- Estimated Tech Debt: $${(dp.estimated_tech_debt || 0).toLocaleString()}
- Annual Licensing Cost: $${(dp.annual_licensing_cost || 0).toLocaleString()}
- Annual Tech Cost: $${(dp.annual_tech_cost || 0).toLocaleString()}
- Remediation Effort: ${dp.remediation_effort || 'Not estimated'}

SOFTWARE PRODUCTS:
${softwareList}

TECHNOLOGY STACK:
${techList}

IT SERVICES CONSUMED:
${serviceList}
  `.trim();

  const metadata = {
    dp_type: dp.dp_type,
    environment: dp.environment,
    hosting_type: dp.hosting_type,
    assessment_status: dp.assessment_status,
    has_tech_debt: (dp.estimated_tech_debt || 0) > 0,
    tech_debt_amount: dp.estimated_tech_debt,
    is_primary: dp.is_primary,
  };

  return { content, metadata };
}


export async function buildSoftwareProductContent(
  supabase: SupabaseClient,
  productId: string
): Promise<{ content: string; metadata: Record<string, any> }> {
  
  const { data: product } = await supabase
    .from('software_products')
    .select(`
      *,
      owner_workspace:workspaces(name),
      manufacturer:organizations!manufacturer_org_id(name),
      deployments:deployment_profile_software_products(
        deployed_version, annual_cost, contract_end_date, cost_confidence,
        deployment_profile:deployment_profiles(
          name,
          application:applications(name, app_id)
        )
      )
    `)
    .eq('id', productId)
    .single();

  if (!product) throw new Error(`Software Product ${productId} not found`);

  // Aggregate deployment info
  const deploymentList = product.deployments?.map((d: any) => {
    const appName = d.deployment_profile?.application?.name || 'Infrastructure';
    return `  - ${appName}: v${d.deployed_version || '?'}, $${(d.annual_cost || 0).toLocaleString()}/yr` +
      (d.contract_end_date ? ` (Contract ends: ${d.contract_end_date})` : '');
  }).join('\n') || '  Not deployed';

  const totalCost = product.deployments?.reduce(
    (sum: number, d: any) => sum + (d.annual_cost || 0), 0
  ) || 0;

  // Find earliest contract expiry
  const contractDates = product.deployments
    ?.filter((d: any) => d.contract_end_date)
    .map((d: any) => new Date(d.contract_end_date))
    .sort((a: Date, b: Date) => a.getTime() - b.getTime());
  const nextExpiry = contractDates?.[0];

  const content = `
SOFTWARE PRODUCT: ${product.name}
Owner Workspace: ${product.owner_workspace?.name}
Manufacturer: ${product.manufacturer?.name || 'Unknown'}

LIFECYCLE:
- State: ${product.lifecycle_state}
- Internal Only: ${product.is_internal_only ? 'Yes' : 'No'}

DESCRIPTION:
${product.description || 'No description provided'}

COST SUMMARY:
- Catalog Annual Cost: $${(product.annual_cost || 0).toLocaleString()}
- Total Deployed Cost: $${totalCost.toLocaleString()}
- Deployment Count: ${product.deployments?.length || 0}
${nextExpiry ? `- Next Contract Expiry: ${nextExpiry.toISOString().split('T')[0]}` : ''}

DEPLOYED TO:
${deploymentList}
  `.trim();

  const metadata = {
    lifecycle_state: product.lifecycle_state,
    manufacturer: product.manufacturer?.name,
    total_cost: totalCost,
    deployment_count: product.deployments?.length || 0,
    has_expiring_contract: !!nextExpiry && nextExpiry < new Date(Date.now() + 180 * 24 * 60 * 60 * 1000),
  };

  return { content, metadata };
}


export async function buildItServiceContent(
  supabase: SupabaseClient,
  serviceId: string
): Promise<{ content: string; metadata: Record<string, any> }> {
  
  const { data: service } = await supabase
    .from('it_services')
    .select(`
      *,
      owner_workspace:workspaces(name),
      service_type:service_types(
        name,
        category:service_type_categories(name)
      ),
      consumers:deployment_profile_it_services(
        allocation_basis, allocation_value,
        deployment_profile:deployment_profiles(
          name,
          application:applications(name, app_id)
        )
      ),
      providers:it_service_providers(
        deployment_profile:deployment_profiles(name, dp_type)
      )
    `)
    .eq('id', serviceId)
    .single();

  if (!service) throw new Error(`IT Service ${serviceId} not found`);

  // List consuming applications
  const consumerList = service.consumers?.map((c: any) => {
    const appName = c.deployment_profile?.application?.name || 'Infrastructure';
    return `  - ${appName} (${c.allocation_basis}: ${c.allocation_value || 'N/A'})`;
  }).join('\n') || '  No consumers';

  // List providing infrastructure
  const providerList = service.providers?.map((p: any) =>
    `  - ${p.deployment_profile?.name} (${p.deployment_profile?.dp_type})`
  ).join('\n') || '  No providers defined';

  const content = `
IT SERVICE: ${service.name}
Owner Workspace: ${service.owner_workspace?.name || 'Central'}
Category: ${service.service_type?.category?.name || 'Uncategorized'}
Type: ${service.service_type?.name || 'Unknown'}

DESCRIPTION:
${service.description || 'No description provided'}

LIFECYCLE & COST:
- Lifecycle State: ${service.lifecycle_state || 'Active'}
- Cost Model: ${service.cost_model || 'Not defined'}
- Annual Cost: $${(service.annual_cost || 0).toLocaleString()}
- Internal Only: ${service.is_internal_only ? 'Yes' : 'No'}

CONSUMING APPLICATIONS:
${consumerList}

PROVIDED BY:
${providerList}
  `.trim();

  const metadata = {
    lifecycle_state: service.lifecycle_state,
    cost_model: service.cost_model,
    annual_cost: service.annual_cost,
    consumer_count: service.consumers?.length || 0,
    category: service.service_type?.category?.name,
  };

  return { content, metadata };
}
```

---

## 3. SWOT Analysis Function

For analytical queries like "Generate a SWOT for Finance workspace", we need structured data fetching:

```typescript
// lib/swot-analyzer.ts

interface SwotData {
  strengths: string[];
  weaknesses: string[];
  opportunities: string[];
  threats: string[];
  stats: {
    totalApps: number;
    assessedApps: number;
    totalBudget: number;
    totalCost: number;
    techDebtTotal: number;
  };
}

export async function generateWorkspaceSwot(
  supabase: SupabaseClient,
  workspaceId: string
): Promise<SwotData> {
  
  // Fetch workspace with aggregated data
  const { data: workspace } = await supabase
    .from('workspaces')
    .select('id, name, budget_amount')
    .eq('id', workspaceId)
    .single();

  // Get all apps with their assessments
  const { data: apps } = await supabase
    .from('applications')
    .select(`
      id, name, lifecycle_status, annual_cost, budget_amount,
      deployment_profiles(
        assessment_status, estimated_tech_debt, hosting_type, cloud_provider,
        t01, t02, t03, t04, t05, t06, t07, t08, t09, t10, t11, t12, t13, t14, t15
      ),
      portfolio_assignments(
        time_quadrant, paid_quadrant, business_score, technical_score,
        criticality_score, tech_risk_score
      )
    `)
    .eq('workspace_id', workspaceId);

  // Get software with expiring contracts
  const { data: expiringContracts } = await supabase
    .from('vw_software_contract_expiry')
    .select('*')
    .eq('workspace_id', workspaceId)
    .lte('contract_end_date', new Date(Date.now() + 180 * 24 * 60 * 60 * 1000).toISOString());

  // Get budget status
  const { data: budgetStatus } = await supabase
    .from('vw_budget_status')
    .select('*')
    .eq('workspace_id', workspaceId);

  // Analyze the data
  const strengths: string[] = [];
  const weaknesses: string[] = [];
  const opportunities: string[] = [];
  const threats: string[] = [];

  let totalCost = 0;
  let totalTechDebt = 0;
  let assessedCount = 0;

  for (const app of apps || []) {
    const assignment = app.portfolio_assignments?.[0];
    const dp = app.deployment_profiles?.[0];
    
    totalCost += app.annual_cost || 0;
    totalTechDebt += dp?.estimated_tech_debt || 0;
    
    if (dp?.assessment_status === 'complete') assessedCount++;

    // STRENGTHS
    if (assignment?.time_quadrant === 'Invest') {
      strengths.push(`${app.name} - Strategic investment target with strong scores`);
    }
    if (assignment?.business_score >= 7 && assignment?.technical_score >= 7) {
      strengths.push(`${app.name} - High performer (B:${assignment.business_score}, T:${assignment.technical_score})`);
    }
    if (dp?.hosting_type === 'cloud' || dp?.cloud_provider) {
      strengths.push(`${app.name} - Modern cloud infrastructure (${dp.cloud_provider})`);
    }

    // WEAKNESSES
    if (assignment?.time_quadrant === 'Tolerate') {
      weaknesses.push(`${app.name} - In "Tolerate" quadrant, limited investment`);
    }
    if (assignment?.time_quadrant === 'Eliminate') {
      weaknesses.push(`${app.name} - Marked for elimination`);
    }
    if (dp?.assessment_status === 'not_started') {
      weaknesses.push(`${app.name} - Assessment not started`);
    }
    if ((dp?.estimated_tech_debt || 0) > 100000) {
      weaknesses.push(`${app.name} - High tech debt ($${dp.estimated_tech_debt.toLocaleString()})`);
    }
    if (app.lifecycle_status === 'Legacy' || app.lifecycle_status === 'End of Life') {
      weaknesses.push(`${app.name} - ${app.lifecycle_status} status`);
    }

    // OPPORTUNITIES
    if (assignment?.time_quadrant === 'Migrate') {
      opportunities.push(`${app.name} - Migration candidate, modernization opportunity`);
    }
    if (assignment?.criticality_score >= 7 && assignment?.technical_score < 5) {
      opportunities.push(`${app.name} - Critical app with room for technical improvement`);
    }
  }

  // Contract-based THREATS
  for (const contract of expiringContracts || []) {
    threats.push(`${contract.software_product_name} - Contract expires ${contract.contract_end_date}`);
  }

  // Budget-based analysis
  const overBudgetApps = budgetStatus?.filter((b: any) => 
    b.budget_status === 'over_10' || b.budget_status === 'over_critical'
  );
  for (const app of overBudgetApps || []) {
    threats.push(`${app.application_name} - Over budget (${app.budget_status})`);
  }

  // Assessment completion opportunity
  const unassessedCount = (apps?.length || 0) - assessedCount;
  if (unassessedCount > 0) {
    opportunities.push(`${unassessedCount} applications pending assessment - opportunity to complete portfolio view`);
  }

  // Consolidation opportunities (apps with similar names or functions)
  // This would need more sophisticated analysis in production

  return {
    strengths: [...new Set(strengths)].slice(0, 10),
    weaknesses: [...new Set(weaknesses)].slice(0, 10),
    opportunities: [...new Set(opportunities)].slice(0, 10),
    threats: [...new Set(threats)].slice(0, 10),
    stats: {
      totalApps: apps?.length || 0,
      assessedApps: assessedCount,
      totalBudget: workspace?.budget_amount || 0,
      totalCost,
      techDebtTotal: totalTechDebt,
    },
  };
}
```

---

## 4. Query Intent Detection

Detect whether a query needs simple retrieval or complex analysis:

```typescript
// lib/query-classifier.ts

export type QueryIntent = 
  | { type: 'lookup'; entities: string[] }
  | { type: 'swot'; workspaceName?: string }
  | { type: 'comparison'; targets: string[] }
  | { type: 'impact'; trigger: string }
  | { type: 'assessment_status' }
  | { type: 'tech_debt' }
  | { type: 'budget' }
  | { type: 'general' };

export function classifyQuery(query: string): QueryIntent {
  const lowerQuery = query.toLowerCase();
  
  // SWOT analysis
  if (lowerQuery.includes('swot')) {
    const workspaceMatch = query.match(/swot\s+(?:for|of)\s+(?:the\s+)?(.+?)(?:\s+workspace)?$/i);
    return { type: 'swot', workspaceName: workspaceMatch?.[1]?.trim() };
  }
  
  // Impact analysis
  if (lowerQuery.includes('impact') || lowerQuery.includes('if we retire') || 
      lowerQuery.includes('what happens if') || lowerQuery.includes('affected by')) {
    const triggerMatch = query.match(/(?:retire|sunset|remove|eliminate)\s+(.+?)(?:\?|$)/i);
    return { type: 'impact', trigger: triggerMatch?.[1]?.trim() || '' };
  }
  
  // Comparison
  if (lowerQuery.includes('compare') || lowerQuery.includes(' vs ') || 
      lowerQuery.includes('versus') || lowerQuery.includes('difference between')) {
    return { type: 'comparison', targets: [] }; // Would parse targets
  }
  
  // Assessment status
  if (lowerQuery.includes('assessment') || lowerQuery.includes('time quadrant') ||
      lowerQuery.includes('not assessed') || lowerQuery.includes('need assessment')) {
    return { type: 'assessment_status' };
  }
  
  // Tech debt
  if (lowerQuery.includes('tech debt') || lowerQuery.includes('technical debt') ||
      lowerQuery.includes('remediation')) {
    return { type: 'tech_debt' };
  }
  
  // Budget
  if (lowerQuery.includes('budget') || lowerQuery.includes('cost') || 
      lowerQuery.includes('spend') || lowerQuery.includes('over budget')) {
    return { type: 'budget' };
  }
  
  // Default to general lookup
  return { type: 'general' };
}
```

---

## 5. Enhanced Chat Edge Function

```typescript
// supabase/functions/apm-chat/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import Anthropic from "https://esm.sh/@anthropic-ai/sdk@0.24.0";
import { classifyQuery } from "./query-classifier.ts";
import { generateWorkspaceSwot } from "./swot-analyzer.ts";

const anthropic = new Anthropic({ apiKey: Deno.env.get("ANTHROPIC_API_KEY") });
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY");

serve(async (req) => {
  const authHeader = req.headers.get("Authorization")!;
  const supabase = createClient(
    Deno.env.get("SUPABASE_URL")!,
    Deno.env.get("SUPABASE_ANON_KEY")!,
    { global: { headers: { Authorization: authHeader } } }
  );

  // Auth
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return new Response("Unauthorized", { status: 401 });
  
  const namespaceId = user.user_metadata.namespace_id;
  const { query, workspace_id, conversation_history = [] } = await req.json();

  // 1. Classify query intent
  const intent = classifyQuery(query);
  
  // 2. Gather context based on intent
  let contextText = '';
  let supplementalData: any = null;

  if (intent.type === 'swot' && intent.workspaceName) {
    // Find workspace by name
    const { data: workspace } = await supabase
      .from('workspaces')
      .select('id, name')
      .eq('namespace_id', namespaceId)
      .ilike('name', `%${intent.workspaceName}%`)
      .single();
    
    if (workspace) {
      supplementalData = await generateWorkspaceSwot(supabase, workspace.id);
      contextText = `
SWOT ANALYSIS DATA FOR: ${workspace.name}

STATISTICS:
- Total Applications: ${supplementalData.stats.totalApps}
- Assessed Applications: ${supplementalData.stats.assessedApps}
- Total Annual Cost: $${supplementalData.stats.totalCost.toLocaleString()}
- Total Tech Debt: $${supplementalData.stats.techDebtTotal.toLocaleString()}
- Workspace Budget: $${supplementalData.stats.totalBudget.toLocaleString()}

STRENGTHS:
${supplementalData.strengths.map((s: string) => `• ${s}`).join('\n')}

WEAKNESSES:
${supplementalData.weaknesses.map((w: string) => `• ${w}`).join('\n')}

OPPORTUNITIES:
${supplementalData.opportunities.map((o: string) => `• ${o}`).join('\n')}

THREATS:
${supplementalData.threats.map((t: string) => `• ${t}`).join('\n')}
      `.trim();
    }
  } else {
    // Standard vector search
    const embeddingResponse = await fetch("https://api.openai.com/v1/embeddings", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "text-embedding-3-small",
        input: query,
      }),
    });
    
    const { data: embData } = await embeddingResponse.json();
    const queryEmbedding = embData[0].embedding;

    const { data: context } = await supabase.rpc("search_apm_context", {
      query_embedding: queryEmbedding,
      p_namespace_id: namespaceId,
      p_workspace_id: workspace_id || null,
      match_count: 10,
    });

    contextText = context
      .map((item: any) => `[${item.entity_type.toUpperCase()}]\n${item.content}`)
      .join('\n\n---\n\n');
  }

  // 3. Build system prompt
  const systemPrompt = `You are an APM (Application Portfolio Management) assistant for GetInSync.
You help users understand their application portfolio, technologies, assessments, costs, and technical debt.

<terminology>
- TIME Quadrants: Tolerate (maintain minimally), Invest (strategic value), Migrate (modernize), Eliminate (retire)
- PAID Quadrants: Protect, Advance, Innovate, Divest
- B-Scores (B01-B10): Business assessment factors
- T-Scores (T01-T15): Technical assessment factors
- Deployment Profile: WHERE an app runs (environment, hosting, tech stack)
- Workspace: Organizational unit (like a ministry or department)
- Namespace: Top-level tenant
</terminology>

<context>
${contextText || 'No specific context retrieved for this query.'}
</context>

<guidelines>
- Be concise and actionable
- Reference specific applications, technologies, or services by name
- For SWOT analyses, format clearly with the four quadrants
- Explain TIME/PAID classifications when relevant
- If data is missing or incomplete, acknowledge it
- Suggest follow-up questions when appropriate
- When discussing costs, always clarify if it's budget vs actual vs tech debt
</guidelines>`;

  // 4. Stream response
  const stream = await anthropic.messages.stream({
    model: "claude-sonnet-4-20250514",
    max_tokens: 2048,
    system: systemPrompt,
    messages: [
      ...conversation_history,
      { role: "user", content: query }
    ],
  });

  const encoder = new TextEncoder();
  const readable = new ReadableStream({
    async start(controller) {
      for await (const event of stream) {
        if (event.type === "content_block_delta" && event.delta.type === "text_delta") {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ text: event.delta.text })}\n\n`));
        }
      }
      controller.enqueue(encoder.encode("data: [DONE]\n\n"));
      controller.close();
    },
  });

  return new Response(readable, {
    headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache" },
  });
});
```

---

## 6. Example Queries & Expected Behavior

| User Query | Intent | Data Source |
|------------|--------|-------------|
| "Generate a SWOT for Finance workspace" | `swot` | `generateWorkspaceSwot()` → structured analysis |
| "Which apps are marked for migration?" | `assessment_status` | Vector search + filter `time_quadrant='Migrate'` |
| "What's our total tech debt?" | `tech_debt` | Vector search + aggregate `estimated_tech_debt` |
| "If we retire Oracle 11g, what's affected?" | `impact` | Search software_products + trace to apps |
| "Show apps over budget" | `budget` | `vw_budget_status` view |
| "Tell me about the HR Portal" | `lookup` | Vector similarity search |
| "Compare Health vs Finance modernization readiness" | `comparison` | SWOT for both, side-by-side |
| "What contracts expire in the next 6 months?" | `lookup` | `vw_software_contract_expiry` view |

---

## 7. Embedding Triggers

Auto-update embeddings when data changes:

```sql
-- Generic trigger function
create or replace function trigger_embedding_update()
returns trigger as $$
declare
  entity_type text;
begin
  -- Determine entity type from table name
  entity_type := TG_ARGV[0];
  
  -- Queue async embedding update
  perform pg_notify('embedding_updates', json_build_object(
    'entity_type', entity_type,
    'entity_id', NEW.id,
    'namespace_id', coalesce(NEW.namespace_id, (
      select namespace_id from workspaces where id = NEW.workspace_id
    ))
  )::text);
  
  return NEW;
end;
$$ language plpgsql;

-- Create triggers
create trigger embed_applications after insert or update on applications
  for each row execute function trigger_embedding_update('application');

create trigger embed_deployment_profiles after insert or update on deployment_profiles
  for each row execute function trigger_embedding_update('deployment_profile');

create trigger embed_software_products after insert or update on software_products
  for each row execute function trigger_embedding_update('software_product');

create trigger embed_it_services after insert or update on it_services
  for each row execute function trigger_embedding_update('it_service');

create trigger embed_portfolio_assignments after insert or update on portfolio_assignments
  for each row execute function trigger_embedding_update('portfolio_assignment');
```

---

## 8. Implementation Checklist

- [ ] Enable pgvector extension in Supabase
- [ ] Create `apm_embeddings` table with indexes
- [ ] Create `search_apm_context` function
- [ ] Deploy embedding Edge Function
- [ ] Backfill embeddings for existing data
- [ ] Deploy chat Edge Function
- [ ] Add React `<ApmChatPanel />` component
- [ ] Set up database triggers for auto-updates
- [ ] Test with real workspace data
- [ ] Add conversation history persistence (optional)

---

## Cost Estimates (Monthly)

| Component | Estimate |
|-----------|----------|
| OpenAI Embeddings (initial 5K entities + updates) | ~$1-5 |
| Claude API (500 chats × ~3K tokens avg) | ~$20-40 |
| Supabase Pro (includes pgvector) | $25 |
| **Total** | **~$50-70/month** |

---

*Implementation guide based on GetInSync NextGen Schema v2026-01-25*
